stegfs - 2015.06                                          ---- June 2015
================

Changes
-------

* Complete rewrite **NOT BACKWARDS COMPATIBLE**
  - Stores block locations (and other vales) as big endian
  - Change key/IV processing
  - If you see the error message “Previous version of stegfs!” download
    version 2010.01 and recover your data, before creating a new stegfs
	and transferring your data to it
  - Block size is 2,048 bytes
    * 32 indicate the path
	* 1,976 are file data
	* 32 are a data checksum
	* 8 indicate the next block
	* All except the first 32 are encrypted; the cipher can have a block
	  length of:
	  - 128 bits
      - 192 bits
	  - 256 bits
* Allow user configured algorithm (select during mkfs)
* Remove multi-threaded capability (we’ll bring it back soon)
* Files are:
  - Read when they’re opened
  - Written when they’re closed
  - Cached until the file system is unmounted; if could be argued that
    keeping file contents in memory is dangerous but if you’ve mounted
	the file system and accessed files then this is where an attacker is
	likely to strike
* Directories:
  - Still not stored
  - Are cached while mounted
  - Do not need + prefix
  - Do require creating on each mount (if you want to access your files)
* Provide an extreme paranoia mode, where by the standard stegfs header
  block isn’t written, thus disguising the partition.

Ideas For Another Day
---------------------

* Bring back multi-threaded support
* Cache time limit (force forget if a file isn’t accessed)
* Don’t break backwards compatibility (again)!

About
-----

stegfs is a steganographic file system in userspace. Steganographic file
systems allow the user plausible deniability of files within. It
achieves this by becoming a lossy file system: writing a file to the
file system may overwrite an existing file without warning.

The typical use case for stegfs is either as a file on an existing file
system, similar to many other FUSE based file systems, but it can also
function as a file system on its own partition, like traditional
“in-kernel” file systems---it doesn’t really matter. With that in mind,
it’s not expected to be a primary workstation file system, but more of a
USB or SD-card file system. Great for keeping documents hidden from
prying eyes when moving data between systems. (It also works well with
online based storage provides too.)

One suggested way of using stegfs is to have it located as the final
partition on a USB drive, and keep less secret data in the root or
within one or two subdirectories, and then keep more secret data further
down the hierarchy---obviously with each file having a unique password.

stegfs uses a file hierarchy similar to that of conventional file
systems. For each subdirectory, a check is made to ensure that the
current block isn’t already being used by another file down that path.
Files written at deeper levels will not overwrite files above them, but
files in the root directory are likely to overwrite portions of files
further away from the root. Therefore, files at a deeper level are less
likely to overwrite another file, but are more susceptible to being
overwritten themselves.

Files can be stored with or without a password. The convention adopted
for stegfs is “/dir/tree/file:passwd”; that is, everything after a colon
is used at the password for encrypting and decrypting the file. In
addition to this, as with the directory hierarchy and the file name, the
password is also used to locate the header blocks for files.

One point worth making is that even though writing multiple files in one
session ensures that the later files do not overwrite the previous ones,
the same is not true regarding the file inodes/headers. They are written
where they want (their location is deterministic based on the file name/
path). As an example: copying the source code for our encrypt project on
to a stegfs partition causes several of the files to become corrupt and
unrecoverable. Obviously one way to avoid this is to bundle files in to
an archive (tar, zip, etc).

The paranoid mode doesn’t disclose the fact that a stegfs partition is
present; the entire file or device will appear as random data. Whilst
this is good for security it does mean that the stegfs application is
unable to confirm that it is mounting an actual stegfs partition; it
will ignore some basic sanity checks and then succeed regardless---this
could cause serious data loss! You have to way up the risks for
yourself: security and increased plausible deniability, or risk of
destroying data if you accidentally mount something that isn’t a stegfs
partition.

mkstegfs
--------

When creating a stegfs file system, the size of the file created (or the
size of the partition on which it will be created) is shown; this is the
number of bytes (MB, GB, etc) which are used to house everything,
including header information, about the files on the file system. Below
this is the capacity available for actual file data---roughly 95% of a
block is used for data. Finally, the maximum usable space under ideal
conditions where no files are compromised: each file is written 8 times
to minimise the loss, and maximise the chance of being able to recover
it. Under normal working conditions it’s highly likely this value will
never be achieved due to the Birthday Paradox.

By default the mkfs utility will use the Serpent cipher with a 192 bit
key, in cipher block chaining mode, and the Tiger hash algorithm, which
generates 192 bit hashes. These can be changed by passing the
appropriate arguments and values to mkstegfs. You can find a list of
supported algorithms/modes either from encrypt (as it uses libgcrypt) or
from: https://www.gnupg.org/documentation/manuals/gcrypt/
